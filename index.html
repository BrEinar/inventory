<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Inventory</title>
  <style>
    :root {
      color-scheme: light dark;
      --ui-border: rgba(127,127,127,.28);
      --ui-border-strong: rgba(127,127,127,.4);
      --ui-surface: rgba(127,127,127,.08);
    }
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
      padding: 14px;
      max-width: 1100px;
      margin-inline: auto;
    }
    h1 { margin: 0 0 12px; font-size: clamp(20px, 4vw, 28px); }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: end; }
    label { display: grid; gap: 6px; font-size: 12px; opacity: .9; }
    input, select, button, textarea {
      font: inherit; padding: 11px 12px; border: 1px solid var(--ui-border-strong);
      border-radius: 10px; background: transparent;
    }
    input[type="number"] { width: 120px; }
    button { cursor: pointer; min-height: 42px; }
    button.primary { border: none; padding: 10px 14px; border-radius: 12px; }
    .card { border: 1px solid var(--ui-border); border-radius: 14px; padding: 12px; margin: 12px 0; background: var(--ui-surface); }
    .toolbar { display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content: space-between; }
    .toolbar > * { flex: 1 1 auto; }
    .toolbar .right { display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; }
    .table-wrap { overflow:auto; margin-top:10px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 10px 8px; border-bottom: 1px solid rgba(127,127,127,.2); vertical-align: top; }
    th { font-size: 12px; opacity: .8; user-select: none; }
    .muted { opacity: .75; font-size: 12px; }
    .pill { font-size: 12px; padding: 2px 8px; border-radius: 999px; border: 1px solid rgba(127,127,127,.3); display:inline-block; }
    .danger { color: #c00; }
    .grid { display:grid; gap:10px; }
    .split { display:grid; gap:10px; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
    dialog {
      width: min(680px, 96vw);
      border: 1px solid rgba(127,127,127,.35);
      border-radius: 16px;
      padding: 12px;
    }
    dialog::backdrop { background: rgba(0,0,0,.4); }
    .actions { display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; margin-top: 10px; }
    .small { font-size: 12px; }
    .nowrap { white-space: nowrap; }
    .hidden { display: none !important; }
    .auth-wrap { max-width: 460px; margin: max(3vh, 24px) auto 0; }
    .auth-tabs { display:flex; gap:8px; margin-bottom: 12px; }
    .auth-tabs button { flex:1; }
    .status { min-height: 20px; }

    #videoWrap { position: relative; border-radius: 14px; overflow: hidden; border: 1px solid rgba(127,127,127,.25); }
    video { width: 100%; height: auto; display:block; }
    .scanBox {
      position:absolute; inset: 16% 10%;
      border: 2px solid rgba(255,255,255,.7);
      border-radius: 18px;
      box-shadow: 0 0 0 9999px rgba(0,0,0,.25) inset;
      pointer-events:none;
    }

    @media (max-width: 820px) {
      body { padding: 10px; }
      label, .toolbar > *, .toolbar .right, .row > * { width: 100%; }
      input[type="number"] { width: 100%; }
      .toolbar .right { justify-content: stretch; }
      .toolbar .right button,
      .row button,
      .auth-tabs button,
      .actions button { width: 100%; }
      th, td { padding: 8px 6px; }
    }

    @media (max-width: 640px) {
      table thead {
        position: absolute;
        width: 1px;
        height: 1px;
        margin: -1px;
        border: 0;
        clip: rect(0 0 0 0);
        overflow: hidden;
      }
      table, tbody { display: block; }
      tr {
        display: block;
        border: 1px solid var(--ui-border);
        border-radius: 12px;
        padding: 8px;
        margin-bottom: 10px;
        background: var(--ui-surface);
      }
      td {
        display: grid;
        grid-template-columns: 98px 1fr;
        gap: 8px;
        border-bottom: 1px dashed var(--ui-border);
      }
      td:last-child { border-bottom: 0; }
      td::before {
        content: attr(data-label);
        font-size: 11px;
        opacity: .75;
        font-weight: 600;
      }
      td[data-label="Actions"] {
        grid-template-columns: 1fr;
      }
      td[data-label="Actions"]::before { margin-bottom: 2px; }
      td[data-label="Actions"] button { width: calc(50% - 6px); margin: 2px; }
    }
  </style>
</head>
<body>
  <div id="authWrap" class="auth-wrap">
    <h1>üîê Inventory login</h1>
    <div class="muted">Your inventory is encrypted on this device using your password.</div>
    <div class="card" style="margin-top:10px;">
      <div class="auth-tabs">
        <button id="showLogin" class="primary">Login</button>
        <button id="showSignup">Sign up</button>
      </div>

      <div id="loginPanel" class="grid">
        <label>Username<input id="loginUser" autocomplete="username" /></label>
        <label>Password<input id="loginPass" type="password" autocomplete="current-password" /></label>
        <button id="loginBtn" class="primary">Login</button>
      </div>

      <div id="signupPanel" class="grid hidden">
        <label>Username<input id="signupUser" autocomplete="username" /></label>
        <label>Password<input id="signupPass" type="password" autocomplete="new-password" /></label>
        <label>Confirm password<input id="signupPass2" type="password" autocomplete="new-password" /></label>
        <button id="signupBtn" class="primary">Create account</button>
      </div>

      <div id="authStatus" class="muted small status"></div>
    </div>
  </div>

  <main id="app" class="hidden">
  <h1>üì¶ Inventory</h1>
  <div class="muted">Offline storage on this device.</div>

  <div class="card">
    <div class="row">
      <label>
        Item name
        <input id="name" placeholder="e.g., USB-C Cable" autocomplete="off" />
      </label>

      <label>
        SKU / Barcode
        <input id="sku" placeholder="tap Scan to fill" autocomplete="off" />
      </label>

      <div style="display:flex; gap:10px; align-items:end;">
        <button id="scanBtn">Scan</button>
      </div>

      <div style="display:flex; gap:10px; align-items:end;">
        <button id="scanBestBeforeBtn">Scan best before</button>
      </div>

      <label>
        Quantity
        <input id="qty" type="number" min="0" step="1" value="1" />
      </label>
      <label>
        Per-unit amount
        <input id="unitValue" type="number" min="0" step="0.01" value="0" />
      </label>
      <label>
        Unit
        <select id="unitType">
          <option value="">‚Äî</option>
          <option value="g">g</option>
          <option value="kg">kg</option>
          <option value="ml">ml</option>
          <option value="l">l</option>
        </select>
      </label>
      <label>
        Best before
        <input id="bestBefore" type="date" />
      </label>
      <label>
        Location
        <input id="loc" placeholder="e.g., Drawer A" autocomplete="off" />
      </label>
      <label>
        Min stock
        <input id="min" type="number" min="0" step="1" value="0" />
      </label>
      <label style="flex:1">
        Notes
        <input id="notes" placeholder="optional" autocomplete="off" />
      </label>
      <button class="primary" id="addBtn">Add / Update</button>
    </div>

    <div class="muted small" style="margin-top:8px;">
      Tip: SKU/barcode is the unique ID. Add or scan the same SKU again to increase quantity.
    </div>
  </div>

  <div class="card toolbar">
    <div class="row" style="width:100%; align-items:center;">
      <label style="flex: 1;">
        Search (name/SKU/location/notes)
        <input id="search" placeholder="type to filter‚Ä¶" />
      </label>

      <label class="nowrap">
        Low stock
        <select id="lowFilter">
          <option value="all">Show all</option>
          <option value="low">Only low</option>
          <option value="ok">Only ok</option>
        </select>
      </label>

      <label class="nowrap">
        Sort
        <select id="sort">
          <option value="updated_desc">Recently updated</option>
          <option value="name_asc">Name A‚ÜíZ</option>
          <option value="qty_desc">Qty high‚Üílow</option>
          <option value="qty_asc">Qty low‚Üíhigh</option>
          <option value="loc_asc">Location A‚ÜíZ</option>
        </select>
      </label>

      <div class="right">
        <button id="exportJson">Export JSON</button>
        <button id="exportCsv">Export CSV</button>
        <button id="importBtn">Import</button>
        <button class="danger" id="wipe">Wipe</button>
      </div>
    </div>
  </div>

  <div class="card">
    <div id="stats" class="muted"></div>
    <div class="table-wrap">
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th class="nowrap">SKU</th>
            <th class="nowrap">Qty</th>
            <th class="nowrap">Unit / Total</th>
            <th>Location</th>
            <th class="nowrap">Min</th>
            <th class="nowrap">Best before</th>
            <th>Notes</th>
            <th class="nowrap">Updated</th>
            <th class="nowrap">Actions</th>
          </tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>
    </div>
  </div>

  <dialog id="scanDialog">
    <h3 style="margin:0 0 8px;">Scan barcode</h3>
    <div class="muted small">Point at a barcode (EAN/UPC/Code128/QR, etc.).</div>
    <div style="margin-top:10px;" id="videoWrap">
      <video id="video" muted playsinline></video>
      <div class="scanBox"></div>
    </div>
    <div class="actions">
      <button id="stopScan">Close</button>
    </div>
    <div class="muted small" id="scanStatus" style="margin-top:8px;"></div>
  </dialog>

  <dialog id="bestBeforeDialog">
    <h3 style="margin:0 0 8px;">Best before dates</h3>
    <div class="muted small" id="bestBeforeMeta"></div>
    <div id="bestBeforeInputs" class="grid" style="margin-top:10px;"></div>
    <div class="actions">
      <button id="closeBestBefore">Cancel</button>
      <button class="primary" id="saveBestBefore">Save dates</button>
    </div>
  </dialog>


  <div class="card">
    <h2 style="margin:0 0 8px;">üç≥ Recipes</h2>
    <div class="split">
      <div class="grid">
        <label>
          Recipe name
          <input id="recipeName" placeholder="e.g., Pasta salad" autocomplete="off" />
        </label>
        <label>
          Default servings
          <input id="recipeServings" type="number" min="1" step="1" value="1" />
        </label>
        <label>
          Ingredients (one per line: name, amount, unit)
          <textarea id="recipeIngredients" rows="6" placeholder="Tomato, 3, pcs&#10;Olive oil, 30, ml"></textarea>
        </label>
        <button id="addRecipeBtn" class="primary">Add recipe</button>
      </div>
      <div>
        <div class="muted small">Saved recipes</div>
        <div id="recipeList" class="grid" style="margin-top:8px;"></div>
      </div>
    </div>
  </div>

  <div class="card">
    <h2 style="margin:0 0 8px;">üóìÔ∏è Meal plan & shopping list</h2>
    <div class="row">
      <label>
        Start date
        <input id="planStart" type="date" />
      </label>
      <label>
        Days
        <input id="planDays" type="number" min="1" max="60" value="7" />
      </label>
      <label>
        Recipe
        <select id="planRecipe"></select>
      </label>
      <label>
        Servings
        <input id="planServings" type="number" min="1" step="1" value="1" />
      </label>
      <button id="addPlanEntryBtn">Add to period</button>
    </div>
    <div id="planEntries" class="grid" style="margin-top:10px;"></div>
    <div style="margin-top:10px;">
      <button id="buildShoppingBtn" class="primary">Build missing shopping list</button>
    </div>
    <div id="shoppingList" class="grid" style="margin-top:10px;"></div>
  </div>

  <dialog id="importDialog">
    <h3 style="margin:0 0 8px;">Import inventory</h3>
    <div class="muted small">Paste JSON (exported from this app) OR CSV (header row required).</div>
    <div class="grid" style="margin-top:10px;">
      <textarea id="importText" rows="10" placeholder="Paste JSON or CSV here"></textarea>
    </div>
    <div class="actions">
      <button id="closeImport">Cancel</button>
      <button class="primary" id="doImport">Import</button>
    </div>
  </dialog>

  <script src="https://unpkg.com/@zxing/library@latest"></script>

<script>
(() => {
  const STORAGE_KEY = "inventory_v1";
  const AUTH_KEY = "inventory_auth_v1";
  const ENC_KEY_PREFIX = "inventory_encrypted_v1_";
  const PBKDF2_ITERATIONS = 210000;
  const $ = (id) => document.getElementById(id);

  const els = {
    app: $("app"),
    authWrap: $("authWrap"),
    authStatus: $("authStatus"),
    showLogin: $("showLogin"),
    showSignup: $("showSignup"),
    loginPanel: $("loginPanel"),
    signupPanel: $("signupPanel"),
    loginUser: $("loginUser"),
    loginPass: $("loginPass"),
    loginBtn: $("loginBtn"),
    signupUser: $("signupUser"),
    signupPass: $("signupPass"),
    signupPass2: $("signupPass2"),
    signupBtn: $("signupBtn"),

    name: $("name"),
    sku: $("sku"),
    qty: $("qty"),
    unitValue: $("unitValue"),
    unitType: $("unitType"),
    loc: $("loc"),
    min: $("min"),
    notes: $("notes"),
    addBtn: $("addBtn"),
    scanBtn: $("scanBtn"),
    scanBestBeforeBtn: $("scanBestBeforeBtn"),
    bestBefore: $("bestBefore"),

    search: $("search"),
    lowFilter: $("lowFilter"),
    sort: $("sort"),
    rows: $("rows"),
    stats: $("stats"),

    exportJson: $("exportJson"),
    exportCsv: $("exportCsv"),
    importBtn: $("importBtn"),
    wipe: $("wipe"),

    importDialog: $("importDialog"),
    importText: $("importText"),
    closeImport: $("closeImport"),
    doImport: $("doImport"),

    scanDialog: $("scanDialog"),
    video: $("video"),
    stopScan: $("stopScan"),
    scanStatus: $("scanStatus"),

    bestBeforeDialog: $("bestBeforeDialog"),
    bestBeforeMeta: $("bestBeforeMeta"),
    bestBeforeInputs: $("bestBeforeInputs"),
    closeBestBefore: $("closeBestBefore"),
    saveBestBefore: $("saveBestBefore"),

    recipeName: $("recipeName"),
    recipeServings: $("recipeServings"),
    recipeIngredients: $("recipeIngredients"),
    addRecipeBtn: $("addRecipeBtn"),
    recipeList: $("recipeList"),

    planStart: $("planStart"),
    planDays: $("planDays"),
    planRecipe: $("planRecipe"),
    planServings: $("planServings"),
    addPlanEntryBtn: $("addPlanEntryBtn"),
    planEntries: $("planEntries"),
    buildShoppingBtn: $("buildShoppingBtn"),
    shoppingList: $("shoppingList"),
  };

  let items = [];
  let editingId = null;
  let editingBestBeforeId = null;
  let currentUser = null;
  let sessionKey = null;
  let recipes = [];
  let mealPlan = { start: "", days: 7, entries: [] };

  function nowISO() { return new Date().toISOString(); }
  function clampInt(v) {
    const n = Number(v);
    if (!Number.isFinite(n)) return 0;
    return Math.max(0, Math.round(n));
  }
  function clampFloat(v) {
    const n = Number(v);
    if (!Number.isFinite(n)) return 0;
    return Math.max(0, n);
  }
  function escapeHtml(s) {
    return String(s ?? "").replace(/[&<>"']/g, c => ({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}[c]));
  }
  function fmtDate(iso) {
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return "";
    return d.toLocaleString();
  }
  function b64FromBytes(buf) {
    return btoa(String.fromCharCode(...new Uint8Array(buf)));
  }
  function bytesFromB64(s) {
    return Uint8Array.from(atob(s), c => c.charCodeAt(0));
  }

  function normalizeItem(x) {
    if (!x) return null;
    const incomingDates = Array.isArray(x.bestBeforeDates) ? x.bestBeforeDates.map(d => String(d ?? "").trim()).filter(Boolean) : [];
    const qty = clampInt(x.qty ?? 0);
    const bestBeforeDates = incomingDates.slice(0, qty);
    while (bestBeforeDates.length < qty) bestBeforeDates.push("");
    return {
      id: String(x.id ?? crypto.randomUUID()),
      name: String(x.name ?? "").trim(),
      sku: String(x.sku ?? "").trim(),
      qty,
      unitValue: clampFloat(x.unitValue ?? 0),
      unitType: ["g", "kg", "ml", "l"].includes(String(x.unitType ?? "").toLowerCase()) ? String(x.unitType).toLowerCase() : "",
      loc: String(x.loc ?? "").trim(),
      min: clampInt(x.min ?? 0),
      bestBeforeDates,
      notes: String(x.notes ?? "").trim(),
      updatedAt: String(x.updatedAt ?? nowISO()),
    };
  }


  function normalizeRecipeIngredient(x) {
    if (!x) return null;
    const name = String(x.name ?? "").trim();
    if (!name) return null;
    const amount = clampFloat(x.amount ?? 0);
    const unitRaw = String(x.unit ?? "").trim().toLowerCase();
    const unit = ["g","kg","ml","l","pcs",""] .includes(unitRaw) ? unitRaw : "";
    return { name, amount, unit };
  }

  function normalizeRecipe(x) {
    if (!x) return null;
    const ingredients = Array.isArray(x.ingredients) ? x.ingredients.map(normalizeRecipeIngredient).filter(Boolean) : [];
    return {
      id: String(x.id ?? crypto.randomUUID()),
      name: String(x.name ?? "").trim(),
      servings: Math.max(1, clampInt(x.servings ?? 1)),
      ingredients,
      updatedAt: String(x.updatedAt ?? nowISO()),
    };
  }

  function normalizePlanEntry(x) {
    if (!x) return null;
    const recipeId = String(x.recipeId ?? "").trim();
    if (!recipeId) return null;
    return { id: String(x.id ?? crypto.randomUUID()), recipeId, servings: Math.max(1, clampInt(x.servings ?? 1)) };
  }

  async function deriveKeyMaterial(password) {
    return crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveBits", "deriveKey"]);
  }

  async function deriveAuth(material, salt, iterations) {
    const bits = await crypto.subtle.deriveBits({ name: "PBKDF2", salt, iterations, hash: "SHA-256" }, material, 256);
    return new Uint8Array(bits);
  }

  async function deriveAesKey(material, salt, iterations) {
    return crypto.subtle.deriveKey({ name: "PBKDF2", salt, iterations, hash: "SHA-256" }, material, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
  }

  function getAuthRecord() {
    try {
      const parsed = JSON.parse(localStorage.getItem(AUTH_KEY) || "null");
      if (!parsed || !parsed.username || !parsed.salt || !parsed.pwdHash) return null;
      return parsed;
    } catch { return null; }
  }

  function timingSafeEqual(a, b) {
    if (a.length !== b.length) return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++) diff |= (a[i] ^ b[i]);
    return diff === 0;
  }

  async function save() {
    if (!sessionKey || !currentUser) return;
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const payload = { version: 2, items, recipes, mealPlan };
    const plain = new TextEncoder().encode(JSON.stringify(payload));
    const cipher = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, sessionKey, plain);
    localStorage.setItem(ENC_KEY_PREFIX + currentUser, JSON.stringify({ iv: b64FromBytes(iv), data: b64FromBytes(cipher) }));
  }

  async function load() {
    const encRaw = localStorage.getItem(ENC_KEY_PREFIX + currentUser);
    if (!encRaw) {
      const legacyRaw = localStorage.getItem(STORAGE_KEY);
      if (!legacyRaw) return { items: [], recipes: [], mealPlan: { start: "", days: 7, entries: [] } };
      try {
        const parsed = JSON.parse(legacyRaw);
        if (!Array.isArray(parsed)) return { items: [], recipes: [], mealPlan: { start: "", days: 7, entries: [] } };
        const migrated = parsed.map(normalizeItem).filter(Boolean);
        items = migrated;
        recipes = [];
        mealPlan = { start: "", days: 7, entries: [] };
        await save();
        localStorage.removeItem(STORAGE_KEY);
        return { items: migrated, recipes: [], mealPlan };
      } catch { return { items: [], recipes: [], mealPlan: { start: "", days: 7, entries: [] } }; }
    }

    try {
      const payload = JSON.parse(encRaw);
      const iv = bytesFromB64(payload.iv);
      const data = bytesFromB64(payload.data);
      const plain = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, sessionKey, data);
      const parsed = JSON.parse(new TextDecoder().decode(plain));
      if (Array.isArray(parsed)) {
        return { items: parsed.map(normalizeItem).filter(Boolean), recipes: [], mealPlan: { start: "", days: 7, entries: [] } };
      }
      const loadedItems = Array.isArray(parsed?.items) ? parsed.items.map(normalizeItem).filter(Boolean) : [];
      const loadedRecipes = Array.isArray(parsed?.recipes) ? parsed.recipes.map(normalizeRecipe).filter(Boolean) : [];
      const loadedPlan = parsed?.mealPlan || {};
      const entries = Array.isArray(loadedPlan.entries) ? loadedPlan.entries.map(normalizePlanEntry).filter(Boolean) : [];
      return { items: loadedItems, recipes: loadedRecipes, mealPlan: { start: String(loadedPlan.start ?? ""), days: Math.max(1, clampInt(loadedPlan.days ?? 7)), entries } };
    } catch {
      return { items: [], recipes: [], mealPlan: { start: "", days: 7, entries: [] } };
    }
  }

  function setAuthStatus(msg, bad = false) {
    els.authStatus.textContent = msg;
    els.authStatus.style.color = bad ? "#c00" : "";
  }

  function setAuthView(mode) {
    const loginMode = mode === "login";
    els.loginPanel.classList.toggle("hidden", !loginMode);
    els.signupPanel.classList.toggle("hidden", loginMode);
    els.showLogin.classList.toggle("primary", loginMode);
    els.showSignup.classList.toggle("primary", !loginMode);
    setAuthStatus("");
  }

  async function signup() {
    const username = els.signupUser.value.trim();
    const password = els.signupPass.value;
    const password2 = els.signupPass2.value;
    if (!username || username.length < 3) return setAuthStatus("Username must be at least 3 characters.", true);
    if (getAuthRecord()) return setAuthStatus("Account already exists on this device. Please login.", true);
    if (password.length < 10) return setAuthStatus("Password must be at least 10 characters.", true);
    if (password !== password2) return setAuthStatus("Passwords do not match.", true);

    const material = await deriveKeyMaterial(password);
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const authHash = await deriveAuth(material, salt, PBKDF2_ITERATIONS);
    localStorage.setItem(AUTH_KEY, JSON.stringify({ username, salt: b64FromBytes(salt), pwdHash: b64FromBytes(authHash), iterations: PBKDF2_ITERATIONS }));
    els.loginUser.value = username;
    els.loginPass.value = "";
    setAuthView("login");
    setAuthStatus("Account created. You can now login.");
  }

  async function login() {
    const rec = getAuthRecord();
    if (!rec) return setAuthStatus("No account found. Please sign up first.", true);

    const username = els.loginUser.value.trim();
    const password = els.loginPass.value;
    if (username !== rec.username) return setAuthStatus("Invalid username or password.", true);

    const material = await deriveKeyMaterial(password);
    const salt = bytesFromB64(rec.salt);
    const iterations = clampInt(rec.iterations || PBKDF2_ITERATIONS);
    const tryHash = await deriveAuth(material, salt, iterations);
    const savedHash = bytesFromB64(rec.pwdHash);
    if (!timingSafeEqual(tryHash, savedHash)) return setAuthStatus("Invalid username or password.", true);

    sessionKey = await deriveAesKey(material, salt, iterations);
    currentUser = rec.username;
    const loaded = await load();
    items = loaded.items;
    recipes = loaded.recipes;
    mealPlan = loaded.mealPlan;
    els.authWrap.classList.add("hidden");
    els.app.classList.remove("hidden");
    render();
  }

  function makeBestBeforeDates(qty, dateValue = "") {
    const out = [];
    const cleanDate = String(dateValue ?? "").trim();
    for (let i = 0; i < clampInt(qty); i++) out.push(cleanDate);
    return out;
  }
  function resizeBestBeforeDates(arr, qty, fillDate = "") {
    const out = Array.isArray(arr) ? arr.slice(0, clampInt(qty)) : [];
    const cleanDate = String(fillDate ?? "").trim();
    while (out.length < clampInt(qty)) out.push(cleanDate);
    return out;
  }
  function appendBestBeforeDates(existingDates, existingQty, addQty, dateValue = "") {
    const preserved = resizeBestBeforeDates(existingDates, existingQty, "");
    return preserved.concat(makeBestBeforeDates(addQty, dateValue));
  }
  function formatBestBeforeSummary(it) {
    const withDates = (it.bestBeforeDates || []).filter(Boolean).sort();
    if (!it.qty) return "‚Äî";
    if (!withDates.length) return `0/${it.qty} dated`;
    return `${withDates[0]} (${withDates.length}/${it.qty} dated)`;
  }
  function formatMeasure(value, unit) {
    if (!unit || !Number.isFinite(value) || value <= 0) return "‚Äî";
    const fixed = (n) => Number.isInteger(n) ? String(n) : n.toFixed(2).replace(/\.00$/, "").replace(/(\.\d*[1-9])0+$/, "$1");
    if (unit === "g" && value >= 1000) return `${fixed(value / 1000)}kg`;
    if (unit === "ml" && value >= 1000) return `${fixed(value / 1000)}l`;
    return `${fixed(value)}${unit}`;
  }
  function formatUnitAndTotal(it) {
    if (!it.unitType || it.unitValue <= 0) return "‚Äî";
    const each = formatMeasure(it.unitValue, it.unitType);
    const total = formatMeasure(it.unitValue * it.qty, it.unitType);
    return `${each} each ‚Ä¢ ${total} total`;
  }

  function getFilteredSorted() {
    const q = els.search.value.trim().toLowerCase();
    const lowMode = els.lowFilter.value;
    let out = items.slice();
    if (q) out = out.filter(it => `${it.name} ${it.sku} ${it.loc} ${it.notes} ${(it.bestBeforeDates || []).join(" ")}`.toLowerCase().includes(q));
    if (lowMode !== "all") out = out.filter(it => (lowMode === "low") ? (it.qty <= it.min) : (it.qty > it.min));
    const mode = els.sort.value;
    const cmp = {
      updated_desc: (a,b) => b.updatedAt.localeCompare(a.updatedAt),
      name_asc: (a,b) => a.name.localeCompare(b.name),
      qty_desc: (a,b) => b.qty - a.qty || a.name.localeCompare(b.name),
      qty_asc: (a,b) => a.qty - b.qty || a.name.localeCompare(b.name),
      loc_asc: (a,b) => a.loc.localeCompare(b.loc) || a.name.localeCompare(b.name),
    }[mode] || ((a,b) => b.updatedAt.localeCompare(a.updatedAt));
    out.sort(cmp);
    return out;
  }

  function render() {
    const view = getFilteredSorted();
    const lowCount = view.filter(it => it.qty <= it.min).length;
    els.stats.textContent = `Items: ${view.length}  ‚Ä¢  Low stock: ${lowCount}  ‚Ä¢  Total unique SKUs: ${new Set(view.map(i => i.sku).filter(Boolean)).size}`;
    els.rows.innerHTML = "";
    for (const it of view) {
      const low = it.qty <= it.min;
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td data-label="Name"><strong>${escapeHtml(it.name || "(unnamed)")}</strong> ${low ? `<span class="pill">LOW</span>` : ""}</td>
        <td class="nowrap" data-label="SKU">${escapeHtml(it.sku)}</td>
        <td class="nowrap" data-label="Qty">${it.qty}</td>
        <td class="nowrap" data-label="Unit / Total">${escapeHtml(formatUnitAndTotal(it))}</td>
        <td data-label="Location">${escapeHtml(it.loc)}</td>
        <td class="nowrap" data-label="Min">${it.min}</td>
        <td class="nowrap" data-label="Best before">${escapeHtml(formatBestBeforeSummary(it))}</td>
        <td data-label="Notes">${escapeHtml(it.notes)}</td>
        <td class="muted nowrap" data-label="Updated">${escapeHtml(fmtDate(it.updatedAt))}</td>
        <td class="nowrap" data-label="Actions">
          <button data-act="edit" data-id="${it.id}">Edit</button>
          <button data-act="dates" data-id="${it.id}">Dates</button>
          <button data-act="plus" data-id="${it.id}">+1</button>
          <button data-act="minus" data-id="${it.id}">-1</button>
          <button class="danger" data-act="del" data-id="${it.id}">Delete</button>
        </td>`;
      els.rows.appendChild(tr);
    }
    renderRecipes();
    renderMealPlan();
    save().catch(() => {});
  }

  function upsertFromForm() { /* unchanged logic */
    const name = els.name.value.trim();
    const sku = els.sku.value.trim();
    const qty = clampInt(els.qty.value);
    const unitValue = clampFloat(els.unitValue.value);
    const unitType = String(els.unitType.value || "").trim().toLowerCase();
    const bestBefore = els.bestBefore.value;
    const loc = els.loc.value.trim();
    const min = clampInt(els.min.value);
    const notes = els.notes.value.trim();
    const hasUnitInput = unitValue > 0 || Boolean(unitType);
    if (!name && !sku) { alert("Add at least a name or SKU."); return; }
    let it = sku ? items.find(x => x.sku.toLowerCase() === sku.toLowerCase()) : null;
    if (!it) {
      it = normalizeItem({ id: crypto.randomUUID(), name, sku, qty, unitValue, unitType, loc, min, notes, bestBeforeDates: makeBestBeforeDates(qty, bestBefore), updatedAt: nowISO() });
      items.push(it);
    } else {
      const previousQty = it.qty;
      const isEditingThisItem = editingId && editingId === it.id;
      it.name = name || it.name;
      if (isEditingThisItem) {
        it.qty = qty;
        it.bestBeforeDates = resizeBestBeforeDates(it.bestBeforeDates, qty, bestBefore);
      } else {
        it.qty = clampInt(it.qty + qty);
        it.bestBeforeDates = appendBestBeforeDates(it.bestBeforeDates, previousQty, qty, bestBefore);
      }
      if (isEditingThisItem || hasUnitInput) {
        it.unitValue = unitValue;
        it.unitType = ["g", "kg", "ml", "l"].includes(unitType) ? unitType : "";
      }
      it.loc = loc; it.min = min; it.notes = notes; it.updatedAt = nowISO();
    }
    editingId = null;
    els.name.value = ""; els.sku.value = ""; els.qty.value = "1"; els.unitValue.value = "0"; els.unitType.value = ""; els.loc.value = ""; els.min.value = "0"; els.bestBefore.value = ""; els.notes.value = "";
    els.name.focus();
    render();
  }

  function prefillMeasureFromExistingSku(skuValue) {
    const sku = String(skuValue ?? "").trim();
    if (!sku) return;
    const existing = items.find(x => x.sku.toLowerCase() === sku.toLowerCase());
    if (!existing) return;
    if (existing.unitValue > 0 && clampFloat(els.unitValue.value) <= 0) els.unitValue.value = String(existing.unitValue);
    if (existing.unitType && !els.unitType.value) els.unitType.value = existing.unitType;
  }

  function editToForm(id) { const it = items.find(x => x.id === id); if (!it) return; editingId = id; els.name.value = it.name; els.sku.value = it.sku; els.qty.value = String(it.qty); els.unitValue.value = String(it.unitValue || 0); els.unitType.value = it.unitType || ""; els.loc.value = it.loc; els.min.value = String(it.min); els.bestBefore.value = it.bestBeforeDates.find(Boolean) || ""; els.notes.value = it.notes; window.scrollTo({ top: 0, behavior: "smooth" }); els.name.focus(); }
  function adjustQty(id, delta) { const it = items.find(x => x.id === id); if (!it) return; it.qty = clampInt(it.qty + delta); it.bestBeforeDates = resizeBestBeforeDates(it.bestBeforeDates, it.qty, ""); it.updatedAt = nowISO(); render(); }
  function editBestBeforeDates(id) { const it = items.find(x => x.id === id); if (!it) return; editingBestBeforeId = id; els.bestBeforeMeta.textContent = `${it.name || "(unnamed)"} ‚Ä¢ Qty: ${it.qty}`; els.bestBeforeInputs.innerHTML = ""; for (let i = 0; i < it.qty; i++) { const row = document.createElement("label"); row.innerHTML = `Unit ${i + 1}<input type="date" data-best-before-index="${i}" value="${escapeHtml(it.bestBeforeDates?.[i] || "")}" />`; els.bestBeforeInputs.appendChild(row);} openDialog(els.bestBeforeDialog); }
  function saveBestBeforeDates() { const it = items.find(x => x.id === editingBestBeforeId); if (!it) return; const inputs = [...els.bestBeforeInputs.querySelectorAll("input[data-best-before-index]")]; it.bestBeforeDates = inputs.sort((a,b)=>Number(a.dataset.bestBeforeIndex)-Number(b.dataset.bestBeforeIndex)).map(input => String(input.value || "").trim()); it.updatedAt = nowISO(); editingBestBeforeId = null; closeDialog(els.bestBeforeDialog); render(); }
  function delItem(id) { const it = items.find(x => x.id === id); if (!it) return; if (!confirm(`Delete "${it.name || it.sku || "item"}"?`)) return; items = items.filter(x => x.id !== id); if (editingId === id) editingId = null; render(); }

  function download(filename, text, mime="text/plain") { const blob = new Blob([text], { type: mime }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }
  function exportJSON() { const payload = { version: 1, exportedAt: nowISO(), items }; download(`inventory-backup-${new Date().toISOString().slice(0,10)}.json`, JSON.stringify(payload, null, 2), "application/json"); }
  function toCSVRow(values) { return values.map(v => { const s = String(v ?? ""); return /[,"\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s; }).join(","); }
  function exportCSV() { const header = ["name","sku","qty","unitValue","unitType","loc","min","bestBeforeDates","notes","updatedAt"]; const lines = [toCSVRow(header)]; for (const it of items) lines.push(toCSVRow([it.name, it.sku, it.qty, it.unitValue ?? 0, it.unitType ?? "", it.loc, it.min, (it.bestBeforeDates || []).join("|"), it.notes, it.updatedAt])); download(`inventory-${new Date().toISOString().slice(0,10)}.csv`, lines.join("\n"), "text/csv"); }

  function parseCSV(text) { const rows=[]; let i=0,field="",row=[],inQuotes=false; while(i<text.length){const c=text[i]; if(inQuotes){ if(c==='"'){ if(text[i+1]==='"'){field+='"';i+=2;continue;} inQuotes=false;i++;continue;} field+=c;i++;continue; } else { if(c==='"'){inQuotes=true;i++;continue;} if(c===","){row.push(field);field="";i++;continue;} if(c==="\n"){row.push(field);rows.push(row);field="";row=[];i++;continue;} if(c==="\r"){i++;continue;} field+=c;i++;continue; } } row.push(field); rows.push(row); return rows.filter(r=>r.some(x=>String(x).trim()!=="")); }

  function importData(text) { const t = text.trim(); if (!t) return; try { const obj = JSON.parse(t); let incoming = null; if (Array.isArray(obj)) incoming = obj; else if (obj && Array.isArray(obj.items)) incoming = obj.items; if (incoming) { const normalized = incoming.map(normalizeItem).filter(Boolean); for (const it of normalized) { if (it.sku) { const existing = items.find(x => x.sku.toLowerCase() === it.sku.toLowerCase()); if (existing) { Object.assign(existing, it, { id: existing.id, updatedAt: nowISO() }); continue; } } it.updatedAt = nowISO(); items.push(it); } render(); return { ok: true, msg: `Imported ${normalized.length} item(s) from JSON.` }; } } catch {}
    const rows = parseCSV(t); if (rows.length < 2) return { ok:false, msg:"CSV needs a header row and at least one data row." }; const header = rows[0].map(h => String(h).trim().toLowerCase()); const idx = (key)=>header.indexOf(key); const imported=[];
    for (let r=1; r<rows.length; r++) { const row = rows[r]; const it = normalizeItem({ id: crypto.randomUUID(), name: row[idx("name")] ?? "", sku: row[idx("sku")] ?? "", qty: row[idx("qty")] ?? 0, unitValue: row[idx("unitvalue")] ?? 0, unitType: row[idx("unittype")] ?? "", loc: row[idx("loc")] ?? "", min: row[idx("min")] ?? 0, bestBeforeDates: String(row[idx("bestbeforedates")] ?? "").split("|").map(x=>x.trim()).filter(Boolean), notes: row[idx("notes")] ?? "", updatedAt: row[idx("updatedat")] ?? nowISO() }); if (!it.name && !it.sku) continue; imported.push(it);} for (const it of imported) { if (it.sku) { const existing = items.find(x => x.sku.toLowerCase() === it.sku.toLowerCase()); if (existing) { Object.assign(existing, it, { id: existing.id, updatedAt: nowISO() }); continue; } } it.updatedAt = nowISO(); items.push(it);} render(); return { ok:true, msg:`Imported ${imported.length} item(s) from CSV.`}; }



  function parseRecipeIngredientsText(text) {
    const lines = String(text ?? "").split(/\n+/).map(x => x.trim()).filter(Boolean);
    const out = [];
    for (const line of lines) {
      const parts = line.split(",").map(x => x.trim());
      const name = parts[0] || "";
      const hasExplicitAmount = String(parts[1] ?? "").trim() !== "";
      const parsedAmount = clampFloat(parts[1] ?? 0);
      const amount = hasExplicitAmount && parsedAmount > 0 ? parsedAmount : 1;
      const unit = String(parts[2] ?? "").toLowerCase() || "pcs";
      const ing = normalizeRecipeIngredient({ name, amount, unit });
      if (ing) out.push(ing);
    }
    return out;
  }
  

function addRecipeFromForm() {
    const name = els.recipeName.value.trim();
    if (!name) return alert("Recipe name is required.");
    const servings = Math.max(1, clampInt(els.recipeServings.value));
    const ingredients = parseRecipeIngredientsText(els.recipeIngredients.value);
    if (!ingredients.length) return alert("Add at least one ingredient line.");
    recipes.push(normalizeRecipe({ id: crypto.randomUUID(), name, servings, ingredients, updatedAt: nowISO() }));
    els.recipeName.value = "";
    els.recipeServings.value = "1";
    els.recipeIngredients.value = "";
    render();
  }

  function renderRecipes() {
    els.recipeList.innerHTML = "";
    if (!recipes.length) {
      els.recipeList.innerHTML = `<div class="muted">No recipes yet.</div>`;
    } else {
      for (const rec of recipes.slice().sort((a,b) => a.name.localeCompare(b.name))) {
        const div = document.createElement("div");
        div.className = "card";
        const ingredientPreview = rec.ingredients.map(i => `${escapeHtml(i.name)} (${i.amount || ""}${escapeHtml(i.unit)})`).join(", ");
        div.innerHTML = `<div><strong>${escapeHtml(rec.name)}</strong> <span class="muted small">(${rec.servings} servings)</span></div><div class="muted small">${ingredientPreview}</div><div style="margin-top:8px;"><button class="danger" data-recipe-del="${rec.id}">Delete</button></div>`;
        els.recipeList.appendChild(div);
      }
    }
    els.planRecipe.innerHTML = recipes.length ? recipes.map(r => `<option value="${r.id}">${escapeHtml(r.name)}</option>`).join("") : '<option value="">No recipes</option>';
  }

  function addPlanEntry() {
    mealPlan.start = els.planStart.value;
    mealPlan.days = Math.max(1, clampInt(els.planDays.value));
    const recipeId = els.planRecipe.value;
    if (!recipeId) return;
    mealPlan.entries.push(normalizePlanEntry({ id: crypto.randomUUID(), recipeId, servings: Math.max(1, clampInt(els.planServings.value)) }));
    render();
  }

  function renderMealPlan() {
    els.planStart.value = mealPlan.start || els.planStart.value;
    els.planDays.value = String(mealPlan.days || 7);
    els.planEntries.innerHTML = "";
    if (!mealPlan.entries.length) els.planEntries.innerHTML = `<div class="muted">No recipes selected for this period.</div>`;
    for (const entry of mealPlan.entries) {
      const rec = recipes.find(r => r.id === entry.recipeId);
      const row = document.createElement("div");
      row.className = "row";
      row.innerHTML = `<div>${escapeHtml(rec?.name || "(deleted recipe)")} ‚Ä¢ ${entry.servings} servings</div><button class="danger" data-plan-del="${entry.id}">Remove</button>`;
      els.planEntries.appendChild(row);
    }
  }

  function unitToBase(amount, unit) {
    const u = String(unit || "").toLowerCase();
    if (u === "kg") return { amount: amount * 1000, kind: "mass", unit: "g" };
    if (u === "g") return { amount, kind: "mass", unit: "g" };
    if (u === "l") return { amount: amount * 1000, kind: "volume", unit: "ml" };
    if (u === "ml") return { amount, kind: "volume", unit: "ml" };
    if (u === "pcs" || !u) return { amount, kind: "count", unit: u || "pcs" };
    return { amount, kind: "count", unit: u };
  }

  function buildShoppingList() {
    mealPlan.start = els.planStart.value;
    mealPlan.days = Math.max(1, clampInt(els.planDays.value));
    const required = new Map();
    for (const entry of mealPlan.entries) {
      const rec = recipes.find(r => r.id === entry.recipeId);
      if (!rec) continue;
      const scale = entry.servings / Math.max(1, rec.servings);
      for (const ing of rec.ingredients) {
        const key = ing.name.trim().toLowerCase();
        const base = unitToBase(ing.amount * scale, ing.unit);
        if (!required.has(key)) required.set(key, { name: ing.name, amount: 0, kind: base.kind, unit: base.unit });
        const r = required.get(key);
        r.amount += base.amount;
      }
    }

    const available = new Map();
    for (const it of items) {
      const key = it.name.trim().toLowerCase();
      if (!key) continue;
      let base;
      if (it.unitType && it.unitValue > 0) base = unitToBase(it.qty * it.unitValue, it.unitType);
      else base = unitToBase(it.qty, "pcs");
      if (!available.has(key)) available.set(key, { amount: 0, kind: base.kind });
      available.get(key).amount += base.amount;
    }

    els.shoppingList.innerHTML = "";
    const missing = [];
    for (const [key, req] of required.entries()) {
      const have = available.get(key);
      const haveAmount = have && have.kind === req.kind ? have.amount : 0;
      const miss = Math.max(0, req.amount - haveAmount);
      if (miss > 0) missing.push({ name: req.name, amount: miss, unit: req.unit, kind: req.kind });
    }
    if (!missing.length) {
      els.shoppingList.innerHTML = `<div class="pill">Everything needed is already in inventory üéâ</div>`;
      return;
    }
    for (const m of missing.sort((a,b) => a.name.localeCompare(b.name))) {
      const amount = (m.unit === "g" && m.amount >= 1000) ? `${(m.amount/1000).toFixed(2).replace(/\.00$/, "")} kg` : (m.unit === "ml" && m.amount >= 1000) ? `${(m.amount/1000).toFixed(2).replace(/\.00$/, "")} l` : `${Number.isInteger(m.amount) ? m.amount : m.amount.toFixed(2)} ${m.unit || "pcs"}`;
      const div = document.createElement("div");
      div.className = "card";
      div.textContent = `${m.name}: ${amount}`;
      els.shoppingList.appendChild(div);
    }
  }

  let codeReader = null;
  function openDialog(el){ if (typeof el.showModal === "function") el.showModal(); else el.setAttribute("open",""); }
  function closeDialog(el){ if (typeof el.close === "function") el.close(); else el.removeAttribute("open"); }
  function parseMeasureText(rawText) {
    const text = String(rawText ?? "").trim().toLowerCase();
    if (!text) return null;
    const m = text.match(/(\d+(?:[.,]\d+)?)\s*(kg|g|l|ml)\b/);
    if (!m) return null;
    const numeric = Number(m[1].replace(",", "."));
    if (!Number.isFinite(numeric) || numeric <= 0) return null;
    return { unitValue: numeric, unitType: m[2] };
  }
  function parseMeasureFromGs1Barcode(rawBarcode) {
    const raw = String(rawBarcode ?? "").trim();
    if (!raw) return null;
    const cleaned = raw.replace(/[()\s]/g, "");
    const aiMatch = cleaned.match(/(?:310|315|320|316)(\d)(\d{6})/);
    if (!aiMatch) return null;
    const aiPrefix = cleaned.slice(aiMatch.index, aiMatch.index + 3);
    const decimals = Number(aiMatch[1]);
    const digits = Number(aiMatch[2]);
    if (!Number.isInteger(decimals) || !Number.isFinite(digits)) return null;
    const unitValue = digits / (10 ** decimals);
    const unitType = (aiPrefix === "310" || aiPrefix === "320") ? "kg" : "l";
    if (!Number.isFinite(unitValue) || unitValue <= 0) return null;
    return { unitValue, unitType };
  }
  function fillUnitFromMeasure(measure) {
    if (!measure) return false;
    if (clampFloat(els.unitValue.value) > 0 && els.unitType.value) return false;
    els.unitValue.value = String(measure.unitValue);
    els.unitType.value = measure.unitType;
    return true;
  }
  async function fetchProductByBarcode(barcode) {
    const code = String(barcode ?? "").trim();
    if (!code) return null;
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), 4500);
    try {
      const res = await fetch(`https://world.openfoodfacts.org/api/v2/product/${encodeURIComponent(code)}.json`, { signal: controller.signal });
      if (!res.ok) return null;
      const data = await res.json();
      const product = data?.product || null;
      if (!product) return null;
      return {
        name: String(product.product_name || product.product_name_en || "").trim(),
        measure: parseMeasureText(product.quantity),
      };
    } catch {
      return null;
    } finally { clearTimeout(timer); }
  }
  async function autoFillFromBarcode(barcode) {
    const product = await fetchProductByBarcode(barcode);
    if (els.sku.value.trim() !== barcode) return;
    if (product?.name && !els.name.value.trim()) els.name.value = product.name;
    const filledMeasure = fillUnitFromMeasure(product?.measure);
    if (product?.name || filledMeasure) {
      const parts = [];
      if (product?.name) parts.push("name");
      if (filledMeasure) parts.push("measure");
      els.scanStatus.textContent = `Scanned: ${barcode} (${parts.join(" + ")} found online)`;
      els.qty.focus();
      return;
    }
    els.scanStatus.textContent = `Scanned: ${barcode} (no product details found online)`;
    els.name.focus();
  }
  function parseBestBeforeFromScan(text) { const raw = String(text ?? "").trim(); if (!raw) return ""; if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) return raw; const dmyOrMdy = raw.match(/\b(\d{1,2})[\/.\-](\d{1,2})[\/.\-](\d{2,4})\b/); if (dmyOrMdy) { let a = Number(dmyOrMdy[1]); let b = Number(dmyOrMdy[2]); let y = Number(dmyOrMdy[3]); if (y < 100) y += 2000; const day = a > 12 ? a : b; const month = a > 12 ? b : a; return `${y}-${String(month).padStart(2, "0")}-${String(day).padStart(2, "0")}`; } const ymd = raw.match(/\b(\d{4})(\d{2})(\d{2})\b/); if (ymd) return `${ymd[1]}-${ymd[2]}-${ymd[3]}`; return ""; }
  async function startScan(mode = "sku") { if (!window.isSecureContext) { alert("Camera access is blocked because this page isn't opened in a secure context."); return; } if (!navigator.mediaDevices?.getUserMedia) { alert("Camera API not available in this browser."); return; } if (!window.ZXing) { alert("Scanner library failed to load (need internet)."); return; }
    els.scanStatus.textContent = "Starting camera‚Ä¶"; openDialog(els.scanDialog); codeReader = new ZXing.BrowserMultiFormatReader();
    try { const constraints = { video: { facingMode: { ideal: "environment" } }, audio: false }; await codeReader.decodeFromConstraints(constraints, els.video, (result, err) => { if (result?.text) { const value = result.text.trim(); stopScan(); if (mode === "bestBefore") { const parsedDate = parseBestBeforeFromScan(value); if (parsedDate) { els.bestBefore.value = parsedDate; els.scanStatus.textContent = `Scanned best before date: ${parsedDate}`; } else { els.scanStatus.textContent = `Scanned text did not look like a date: ${value}`; } els.bestBefore.focus(); } else { els.sku.value = value; const parsedMeasure = parseMeasureFromGs1Barcode(value); const filledFromScan = fillUnitFromMeasure(parsedMeasure); const existing = items.find(x => x.sku.toLowerCase() === value.toLowerCase()); if (existing?.name) { els.name.value = existing.name; els.scanStatus.textContent = `Scanned: ${value} (${filledFromScan ? "name + measure" : "name"} auto-filled from inventory)`; els.qty.focus(); } else { els.scanStatus.textContent = `Scanned: ${value}${filledFromScan ? " (measure found in barcode)." : "."} Looking up details online‚Ä¶`; autoFillFromBarcode(value); } } return; }
      if (!err) return; if (err.name === "NotFoundException") { els.scanStatus.textContent = "Scanning‚Ä¶"; return; } els.scanStatus.textContent = `Scanner error: ${err.message || err.name || "Unknown error"}`; }); } catch (e) { els.scanStatus.textContent = `Could not start camera: ${e?.message || e}`; } }
  function stopScan() { try { codeReader?.reset(); } catch {} codeReader = null; try { const stream = els.video.srcObject; if (stream) stream.getTracks().forEach(t => t.stop()); els.video.srcObject = null; } catch {} closeDialog(els.scanDialog); }

  els.showLogin.addEventListener("click", () => setAuthView("login"));
  els.showSignup.addEventListener("click", () => setAuthView("signup"));
  els.signupBtn.addEventListener("click", () => signup().catch(() => setAuthStatus("Could not create account.", true)));
  els.loginBtn.addEventListener("click", () => login().catch(() => setAuthStatus("Login failed.", true)));
  [els.loginPass, els.loginUser].forEach(el => el.addEventListener("keydown", (e) => { if (e.key === "Enter") login().catch(() => setAuthStatus("Login failed.", true)); }));
  [els.signupPass, els.signupPass2, els.signupUser].forEach(el => el.addEventListener("keydown", (e) => { if (e.key === "Enter") signup().catch(() => setAuthStatus("Could not create account.", true)); }));

  els.addBtn.addEventListener("click", upsertFromForm);
  [els.name, els.sku, els.qty, els.unitValue, els.unitType, els.loc, els.min, els.notes].forEach((input) => input.addEventListener("keydown", (e) => { if (e.key === "Enter") upsertFromForm(); }));
  els.scanBtn.addEventListener("click", () => startScan("sku"));
  els.scanBestBeforeBtn.addEventListener("click", () => startScan("bestBefore"));
  els.sku.addEventListener("input", () => prefillMeasureFromExistingSku(els.sku.value));
  els.sku.addEventListener("blur", () => prefillMeasureFromExistingSku(els.sku.value));
  els.stopScan.addEventListener("click", stopScan);
  els.scanDialog.addEventListener("close", stopScan);
  els.scanDialog.addEventListener("cancel", (e) => { e.preventDefault(); stopScan(); });
  els.rows.addEventListener("click", (e) => { const btn = e.target.closest("button[data-act]"); if (!btn) return; const id = btn.dataset.id; const act = btn.dataset.act; if (act === "edit") editToForm(id); if (act === "dates") editBestBeforeDates(id); if (act === "plus") adjustQty(id, 1); if (act === "minus") adjustQty(id, -1); if (act === "del") delItem(id); });
  [els.search, els.lowFilter, els.sort].forEach(el => { el.addEventListener("input", render); el.addEventListener("change", render); });
  els.exportJson.addEventListener("click", exportJSON);
  els.exportCsv.addEventListener("click", exportCSV);
  els.importBtn.addEventListener("click", () => { els.importText.value = ""; openDialog(els.importDialog); });
  els.closeImport.addEventListener("click", () => closeDialog(els.importDialog));
  els.doImport.addEventListener("click", () => { const res = importData(els.importText.value); if (!res) return; alert(res.msg); if (res.ok) closeDialog(els.importDialog); });
  els.wipe.addEventListener("click", () => { if (!confirm("Delete all inventory items on this device?")) return; items = []; render(); });
  els.closeBestBefore.addEventListener("click", () => { editingBestBeforeId = null; closeDialog(els.bestBeforeDialog); });
  els.saveBestBefore.addEventListener("click", saveBestBeforeDates);


  els.addRecipeBtn.addEventListener("click", addRecipeFromForm);
  els.addPlanEntryBtn.addEventListener("click", addPlanEntry);
  els.buildShoppingBtn.addEventListener("click", buildShoppingList);
  els.recipeList.addEventListener("click", (e) => { const btn = e.target.closest("button[data-recipe-del]"); if (!btn) return; const id = btn.dataset.recipeDel; recipes = recipes.filter(r => r.id !== id); mealPlan.entries = mealPlan.entries.filter(x => x.recipeId !== id); render(); });
  els.planEntries.addEventListener("click", (e) => { const btn = e.target.closest("button[data-plan-del]"); if (!btn) return; const id = btn.dataset.planDel; mealPlan.entries = mealPlan.entries.filter(x => x.id !== id); render(); });
  [els.planStart, els.planDays].forEach(el => el.addEventListener("change", () => { mealPlan.start = els.planStart.value; mealPlan.days = Math.max(1, clampInt(els.planDays.value)); save().catch(() => {}); }));

  setAuthView("login");
})();
</script>
  </main>
</body>
</html>
